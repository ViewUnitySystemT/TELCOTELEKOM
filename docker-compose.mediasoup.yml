# ==========================================
# PeerLink - Mediasoup SFU Konfiguration
# FÃ¼r maximale Kontrolle und Skalierung
# ==========================================

version: '3.8'

services:
  # ===== TRAEFIK REVERSE PROXY MIT LET'S ENCRYPT =====
  traefik:
    image: traefik:v3.1
    container_name: peerlink-traefik
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
      - "8081:8080"  # Traefik Dashboard
    volumes:
      - traefik-acme:/letsencrypt
      - /var/run/docker.sock:/var/run/docker.sock:ro
    environment:
      - DOMAIN=${DOMAIN}
      - LE_EMAIL=${LE_EMAIL}
    command:
      - --api.insecure=false
      - --providers.docker=true
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --certificatesresolvers.le.acme.httpchallenge=true
      - --certificatesresolvers.le.acme.httpchallenge.entrypoint=web
      - --certificatesresolvers.le.acme.email=${LE_EMAIL}
      - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json
    networks:
      - peerlink-network
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.traefik.rule=Host(`traefik.${DOMAIN}`)"
      - "traefik.http.routers.traefik.entrypoints=websecure"
      - "traefik.http.routers.traefik.tls.certresolver=le"
      - "traefik.http.services.traefik.loadbalancer.server.port=8080"

  # ===== COTURN TURN SERVER =====
  coturn:
    image: instrumentisto/coturn
    container_name: peerlink-coturn
    restart: unless-stopped
    network_mode: host   # vereinfacht UDP/NAT, alternativ Ports explizit mappen
    environment:
      - TURN_DOMAIN=${TURN_DOMAIN}
      - TURN_USERNAME=${TURN_USERNAME}
      - TURN_PASSWORD=${TURN_PASSWORD}
      - TURN_PORT=${TURN_PORT}
      - TURNS_PORT=${TURNS_PORT}
      - TURN_MIN_PORT=${TURN_MIN_PORT}
      - TURN_MAX_PORT=${TURN_MAX_PORT}
    command:
      - --no-cli
      - --fingerprint
      - --lt-cred-mech
      - --realm=${TURN_DOMAIN}
      - --user=${TURN_USERNAME}:${TURN_PASSWORD}
      - --no-tls                     # wenn du TLS willst, ersetze durch --cert/--pkey und aktiviere TURNS_PORT
      - --listening-ip=0.0.0.0
      - --listening-ip=::            # IPv6 UnterstÃ¼tzung
      - --listening-port=${TURN_PORT}
      - --min-port=${TURN_MIN_PORT}
      - --max-port=${TURN_MAX_PORT}
      - --verbose
    depends_on:
      - traefik

  # ===== HAUPT-SERVER MIT MEDIASOUP =====
  peerlink-server:
    image: node:20-alpine
    container_name: peerlink-server
    restart: unless-stopped
    working_dir: /app
    volumes:
      - .:/app:ro
      - peerlink_logs:/app/logs
      - peerlink_data:/app/data
      - peerlink_monitoring:/app/monitoring-data.json
    environment:
      - NODE_ENV=production
      - PORT=8080
      - PUBLIC_URL=${PUBLIC_URL}
      - ICE_SERVERS_JSON=${ICE_SERVERS_JSON}
      - PUBLIC_IP=${PUBLIC_IP}        # Ã¶ffentl. IPv4/IPv6 deines Hosts
      - MEDIASOUP_ENABLED=true
      - MEDIASOUP_RTC_MIN_PORT=40000
      - MEDIASOUP_RTC_MAX_PORT=40100
    ports:
      - "40000-40100:40000-40100/udp" # RTP fÃ¼r mediasoup
    command: >
      sh -c "
      echo 'ðŸš€ Starte PeerLink Server mit Mediasoup...';
      npm install mediasoup@^3.12.0;
      node server.js
      "
    networks:
      - peerlink-network
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.peerlink.rule=Host(`${DOMAIN}`)"
      - "traefik.http.routers.peerlink.entrypoints=websecure"
      - "traefik.http.routers.peerlink.tls.certresolver=le"
      - "traefik.http.services.peerlink.loadbalancer.server.port=8080"
    depends_on:
      - traefik
      - coturn

  # ===== REDIS FÃœR MEDIASOUP CLUSTERING =====
  redis:
    image: redis:7-alpine
    container_name: peerlink-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    networks:
      - peerlink-network

  # ===== MONITORING & BACKUP =====
  peerlink-monitor:
    image: alpine:latest
    container_name: peerlink-monitor
    restart: unless-stopped
    volumes:
      - peerlink_logs:/logs:ro
      - peerlink_data:/data:ro
      - peerlink_monitoring:/monitoring:ro
      - peerlink_backup:/backup
    command: >
      sh -c "
      echo 'ðŸ“Š PeerLink Monitoring & Backup Service';
      echo 'ðŸ’¾ Automatische Backups alle 6 Stunden';
      while true; do
        TIMESTAMP=$(date +%Y%m%d_%H%M%S);
        echo \"ðŸ“¦ Erstelle Backup: backup_$TIMESTAMP.tar.gz\";

        # Backup erstellen
        cd / && tar -czf /backup/peerlink_backup_$TIMESTAMP.tar.gz \
          -C /logs . \
          -C /data . \
          -C /monitoring monitoring-data.json 2>/dev/null || true;

        # Alte Backups lÃ¶schen (>7 Tage)
        find /backup -name 'peerlink_backup_*.tar.gz' -mtime +7 -delete 2>/dev/null || true;

        # Backup-Info anzeigen
        echo \"âœ… Backup erstellt: $(ls -lh /backup/peerlink_backup_$TIMESTAMP.tar.gz | awk '{print $5}')\";

        # Backup-Ãœbersicht
        echo \"ðŸ“‚ Backup-Ãœbersicht:\";
        ls -la /backup/ | grep peerlink_backup | tail -5;

        sleep 21600; # 6 Stunden warten
      done
      "
    networks:
      - peerlink-network
    depends_on:
      - peerlink-server

# ===== VOLUMES =====
volumes:
  traefik-acme:
    driver: local
    name: peerlink-traefik-acme

  peerlink_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ./logs

  peerlink_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ./data

  peerlink_monitoring:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ./monitoring-data.json

  peerlink_backup:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ./backup

  redis_data:
    driver: local
    name: peerlink-redis-data

# ===== NETWORKS =====
networks:
  peerlink-network:
    driver: bridge
    name: peerlink-network
